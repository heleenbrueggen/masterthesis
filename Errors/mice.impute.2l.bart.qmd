---
title: "mice.impute.2l.bart"
author: "Heleen Br√ºggen"
format: 
    html:
        toc: true
        number-sections: true
---
```{r}
#| label: setup
#| echo: true
#| message: false
# install_github("heleenbrueggen/mice@impute.mbart")
library(mice)
```
# Example data
```{r}
#| label: data-preparation
data("brandsma", package = "mice")
d <- brandsma[, c("sch", "lpo", "iqv", "den")]
meth <- make.method(d)
meth[c("lpo", "iqv", "den")] <- c("2l.bart", "2l.bart", "2l.bart")
pred <- make.predictorMatrix(d)
pred["lpo", ] <- c(-2, 0, 3, 1)
pred["iqv", ] <- c(-2, 3, 0, 1)
pred["den", ] <- c(-2, 1, 1, 0)
y <- d$lpo
ry <- !is.na(y) 
x <- d[, c("sch", "iqv", "den")]
type <- pred["lpo", c("sch", "iqv", "den")]
```

# Code of (current) working function `mice.impute.2l.bart`
This is the current working code for the imputation function. The `stan4bart` object is fitted by passing the parsed expression for fitting the `stan4bart` model to `eval()`. 
```{r}
#| eval: false
#| code-fold: true
mice.impute.2l.bart <- function(y, ry, x, wy = NULL, type, intercept = TRUE, use.matcher = FALSE, donors = 5L, ...) {
    install.on.demand("stan4bart", ...)
    if (is.null(wy)) {
        wy <- !ry
    }

    if (intercept) {
        x <- cbind(1, as.matrix(x))
        type <- c(2, type)
        names(type)[1] <- colnames(x)[1] <- "(Intercept)"
    }

    clust <- names(type[type == -2])
    rande <- names(type[type == 2])
    fixe <- names(type[type > 0])

    lev <- unique(x[, clust])

    X <- x[, fixe, drop = FALSE]
    Z <- x[, rande, drop = FALSE]
    xobs <- x[ry, , drop = FALSE]
    yobs <- y[ry]
    Xobs <- X[ry, , drop = FALSE]
    Zobs <- Z[ry, , drop = FALSE]

    # create formula
    fr <- ifelse(length(rande) > 1,
        paste0("+ (1 +", paste(rande[-1L], collapse = "+")),
        " + (1 "
    )
    randmodel <- paste0(
        "y ~ bart(", paste0(fixe[-1L], collapse = " + "), ")",
        fr, "| ", clust, ")"
    )

    fit <- eval(parse(text = paste("stan4bart::stan4bart(", randmodel, 
    ", data = data.frame(y, x),
        verbose = -1,
        ...
    )", collapse = "")))
 
#     suppressWarnings(fit <- try(
#     stan4bart::stan4bart(formula(randmodel),
#       data = data.frame(y, x),
#       verbose = -1,
#       ...
#     ),
#     silent = TRUE
#   ))
#   if (inherits(fit, "try-error")) {
#     warning("stan4bart does not run. Simplify imputation model")
#     return(y[wy])
#   }

    yhatobs <- fitted(fit, type = "ev", sample = "train")[ry]
    yhatmis <- fitted(fit, type = "ev", sample = "train")[wy]

    # Find donors
    if (use.matcher) {
        idx <- matcher(yhatobs, yhatmis, k = donors)
    } else {
        idx <- matchindex(yhatobs, yhatmis, donors)
    }

    return(y[ry][idx])
}
```
```{r}
#| label: working-imputation
mice.impute.2l.bart(y, ry, x, type = type)
```

# Passing formula object
Here I will pass the formula object to the `stan4bart` function just as in the `mice.impute.2l.lmer` function.
```{r}
#| eval: false
#| code-fold: true
mice.impute.2l.bart <- function(y, ry, x, wy = NULL, type, intercept = TRUE, use.matcher = FALSE, donors = 5L, ...) {
    install.on.demand("stan4bart", ...)
    if (is.null(wy)) {
        wy <- !ry
    }

    if (intercept) {
        x <- cbind(1, as.matrix(x))
        type <- c(2, type)
        names(type)[1] <- colnames(x)[1] <- "(Intercept)"
    }

    clust <- names(type[type == -2])
    rande <- names(type[type == 2])
    fixe <- names(type[type > 0])

    lev <- unique(x[, clust])

    X <- x[, fixe, drop = FALSE]
    Z <- x[, rande, drop = FALSE]
    xobs <- x[ry, , drop = FALSE]
    yobs <- y[ry]
    Xobs <- X[ry, , drop = FALSE]
    Zobs <- Z[ry, , drop = FALSE]

    # create formula
    fr <- ifelse(length(rande) > 1,
        paste0("+ (1 +", paste(rande[-1L], collapse = "+")),
        " + (1 "
    )
    randmodel <- paste0(
        "y ~ bart(", paste0(fixe[-1L], collapse = " + "), ")",
        fr, "| ", clust, ")"
    )

    fit <- stan4bart::stan4bart(formula = formula(randmodel),
      data = data.frame(y, x),
      verbose = -1,
      ...
    )

    yhatobs <- fitted(fit, type = "ev", sample = "train")[ry]
    yhatmis <- fitted(fit, type = "ev", sample = "train")[wy]

    # Find donors
    if (use.matcher) {
        idx <- matcher(yhatobs, yhatmis, k = donors)
    } else {
        idx <- matchindex(yhatobs, yhatmis, donors)
    }

    return(y[ry][idx])
}
```