cores <- detectCores()
cl <- makeCluster(cores - 1)  # one less than total cores
registerDoParallel(cl)
simdata <- foreach(icount(10), .combine = 'list') %dopar% {
library(tidyverse)
repeat {
# Simulate data
data <- rnorm(n = (ngroup * groupsize), mean = 0, sd = 2.5) %>%
as_tibble() %>%
rename(x1 = value) %>%
mutate(
id = 1:(ngroup * groupsize),
group = rep(1:ngroup, each = groupsize),
eij = rnorm((ngroup * groupsize), mean = 0, sd = 3),
z = rep(rnorm(ngroup, mean = 0, sd = 1), each = groupsize),
u1 = rep(rnorm(ngroup, mean = 0, sd = 0.7), each = groupsize),
u0 = rep(rnorm(ngroup, mean = 0, sd = sqrt((-icc*(g01^2*var(z) + var(x1)*(g11^2*var(z) + var(u1)) + var(eij)) + g01^2*var(z)) / (icc-1))), each = groupsize),
beta0j = g00 + g01 * z + u0,
beta1j = g10 + g11 * z + u1,
y = beta0j + beta1j * x1 + eij
) %>%
select(-eij, -u1)
# Calculate ICC
iccdat <- var(data$beta0j) / var(data$y)
# Check if ICC is close to the desired value
if (abs(iccdat - icc) < 0.1) {
break  # Exit the loop if ICC is close enough to the desired value
} else {
# Adjust the variance of u0 to get closer to the desired ICC
data$u0 <- data$u0 * sqrt(icc / iccdat)
}
}
data <- data %>% select(-u0)
return(data)
}
stopCluster(cl)  # Stop the parallel processing
View(simdata)
View(simdata)
simdata[[1]]
View(simdata[[2]])
registerDoParallel(cl)
simdata <- foreach(icount(10)) %dopar% {
library(tidyverse)
repeat {
# Simulate data
data <- rnorm(n = (ngroup * groupsize), mean = 0, sd = 2.5) %>%
as_tibble() %>%
rename(x1 = value) %>%
mutate(
id = 1:(ngroup * groupsize),
group = rep(1:ngroup, each = groupsize),
eij = rnorm((ngroup * groupsize), mean = 0, sd = 3),
z = rep(rnorm(ngroup, mean = 0, sd = 1), each = groupsize),
u1 = rep(rnorm(ngroup, mean = 0, sd = 0.7), each = groupsize),
u0 = rep(rnorm(ngroup, mean = 0, sd = sqrt((-icc*(g01^2*var(z) + var(x1)*(g11^2*var(z) + var(u1)) + var(eij)) + g01^2*var(z)) / (icc-1))), each = groupsize),
beta0j = g00 + g01 * z + u0,
beta1j = g10 + g11 * z + u1,
y = beta0j + beta1j * x1 + eij
) %>%
select(-eij, -u1)
# Calculate ICC
iccdat <- var(data$beta0j) / var(data$y)
# Check if ICC is close to the desired value
if (abs(iccdat - icc) < 0.1) {
break  # Exit the loop if ICC is close enough to the desired value
} else {
# Adjust the variance of u0 to get closer to the desired ICC
data$u0 <- data$u0 * sqrt(icc / iccdat)
}
}
data <- data %>% select(-u0)
return(data)
}
registerDoParallel(cl)
simdata <- foreach(icount(10)) %dopar% {
library(tidyverse)
repeat {
# Simulate data
data <- rnorm(n = (ngroup * groupsize), mean = 0, sd = 2.5) %>%
as_tibble() %>%
rename(x1 = value) %>%
mutate(
id = 1:(ngroup * groupsize),
group = rep(1:ngroup, each = groupsize),
eij = rnorm((ngroup * groupsize), mean = 0, sd = 3),
z = rep(rnorm(ngroup, mean = 0, sd = 1), each = groupsize),
u1 = rep(rnorm(ngroup, mean = 0, sd = 0.7), each = groupsize),
u0 = rep(rnorm(ngroup, mean = 0, sd = sqrt((-icc*(g01^2*var(z) + var(x1)*(g11^2*var(z) + var(u1)) + var(eij)) + g01^2*var(z)) / (icc-1))), each = groupsize),
beta0j = g00 + g01 * z + u0,
beta1j = g10 + g11 * z + u1,
y = beta0j + beta1j * x1 + eij
) %>%
select(-eij, -u1)
# Calculate ICC
iccdat <- var(data$beta0j) / var(data$y)
# Check if ICC is close to the desired value
if (abs(iccdat - icc) < 0.1) {
break  # Exit the loop if ICC is close enough to the desired value
} else {
# Adjust the variance of u0 to get closer to the desired ICC
data$u0 <- data$u0 * sqrt(icc / iccdat)
}
}
data <- data %>% select(-u0)
return(data)
}
registerDoParallel(cl)
# Using a constraint for data generation to make sure the ICC is .5. Process takes very long
library(foreach)
library(doParallel)
# Simulation data
#############
# Libraries #
#############
library(tidyverse)
library(dplyr)
library(magrittr)
library(psych)
library(mvtnorm)
library(lme4)
library(lmerTest)
library(jtools)
library(irr)
library(purrr)
cores <- detectCores()
cl <- makeCluster(cores - 1)  # one less than total cores
registerDoParallel(cl)
simdata <- foreach(icount(10)) %dopar% {
library(tidyverse)
repeat {
# Simulate data
data <- rnorm(n = (ngroup * groupsize), mean = 0, sd = 2.5) %>%
as_tibble() %>%
rename(x1 = value) %>%
mutate(
id = 1:(ngroup * groupsize),
group = rep(1:ngroup, each = groupsize),
eij = rnorm((ngroup * groupsize), mean = 0, sd = 3),
z = rep(rnorm(ngroup, mean = 0, sd = 1), each = groupsize),
u1 = rep(rnorm(ngroup, mean = 0, sd = 0.7), each = groupsize),
u0 = rep(rnorm(ngroup, mean = 0, sd = sqrt((-icc*(g01^2*var(z) + var(x1)*(g11^2*var(z) + var(u1)) + var(eij)) + g01^2*var(z)) / (icc-1))), each = groupsize),
beta0j = g00 + g01 * z + u0,
beta1j = g10 + g11 * z + u1,
y = beta0j + beta1j * x1 + eij
) %>%
select(-eij, -u1)
# Calculate ICC
iccdat <- var(data$beta0j) / var(data$y)
# Check if ICC is close to the desired value
if (abs(iccdat - icc) < 0.1) {
break  # Exit the loop if ICC is close enough to the desired value
} else {
# Adjust the variance of u0 to get closer to the desired ICC
data$u0 <- data$u0 * sqrt(icc / iccdat)
}
}
data <- data %>% select(-u0)
return(data)
}
stopCluster(cl)  # Stop the parallel processing
View(simdata)
View(simdata[[1]])
simdata %>%
map(~.x %$%
lmer(y ~ 1 + (1|group), REML = FALSE) %>%
summ %>%
.$gvars %>%
.[3]) %>% as.numeric() %>%
Reduce("+", .) / length(simdata)
################
# Checking ICC #
################
# Generating function for ICC calculation
iccfunction <- function (data) {
icc <- var(data$beta0j)/var(data$y)
return(icc)
}
# Checking ICC over all simulated data sets
iccvalue <- rep(0, 1000)
for(i in 1:1000) {
iccvalue[i] <- iccfunction(simdata[[i]])
}
for(i in 1:10) {
iccvalue[i] <- iccfunction(simdata[[i]])
}
mean(iccvalue)
View(simdata[[1]])
############
# Appendix #
############
simdata %>%
map(~.x %$%
var(y)) %>%
Reduce("+", .) / length(simdata)
############
# Appendix #
############
simdata %>%
map(~.x %$%
var(beta0j)) %>%
Reduce("+", .) / length(simdata)
# Checking ICC over all simulated data sets
iccvalue <- rep(0, 1000)
for(i in 1:1000) {
iccvalue[i] <- iccfunction(simdata[[i]])
}
mean(iccvalue)
for(i in 1:10) {
iccvalue[i] <- iccfunction(simdata[[i]])
}
mean(iccvalue)
# Checking ICC over all simulated data sets
iccvalue <- rep(0, 10)
for(i in 1:10) {
iccvalue[i] <- iccfunction(simdata[[i]])
}
mean(iccvalue)
simdata %>%
map(~.x %$%
lmer(y ~ 1 + (1|group), REML = FALSE) %>%
summ %>%
.$gvars %>%
.[3]) %>% as.numeric() %>%
Reduce("+", .) / length(simdata)
registerDoParallel(cl)
simdata <- foreach(icount(10)) %dopar% {
library(tidyverse)
repeat {
# Simulate data
data <- rnorm(n = (ngroup * groupsize), mean = 0, sd = 2.5) %>%
as_tibble() %>%
rename(x1 = value) %>%
mutate(
id = 1:(ngroup * groupsize),
group = rep(1:ngroup, each = groupsize),
eij = rnorm((ngroup * groupsize), mean = 0, sd = 3),
z = rep(rnorm(ngroup, mean = 0, sd = 1), each = groupsize),
u1 = rep(rnorm(ngroup, mean = 0, sd = 0.7), each = groupsize),
u0 = rep(rnorm(ngroup, mean = 0, sd = sqrt((-icc*(g01^2*var(z) + var(x1)*(g11^2*var(z) + var(u1)) + var(eij)) + g01^2*var(z)) / (icc-1))), each = groupsize),
beta0j = g00 + g01 * z + u0,
beta1j = g10 + g11 * z + u1,
y = beta0j + beta1j * x1 + eij
) %>%
select(-eij, -u1)
# Calculate ICC
iccdat <- var(data$beta0j) / var(data$y)
# Check if ICC is close to the desired value
if (abs(iccdat - icc) < 0.01) {
break  # Exit the loop if ICC is close enough to the desired value
} else {
# Adjust the variance of u0 to get closer to the desired ICC
data$u0 <- data$u0 * sqrt(icc / iccdat)
}
}
data <- data %>% select(-u0)
return(data)
}
stopCluster(cl)  # Stop the parallel processing
registerDoParallel(cl)
simdata <- foreach(icount(10)) %dopar% {
library(tidyverse)
repeat {
# Simulate data
data <- rnorm(n = (ngroup * groupsize), mean = 0, sd = 2.5) %>%
as_tibble() %>%
rename(x1 = value) %>%
mutate(
id = 1:(ngroup * groupsize),
group = rep(1:ngroup, each = groupsize),
eij = rnorm((ngroup * groupsize), mean = 0, sd = 3),
z = rep(rnorm(ngroup, mean = 0, sd = 1), each = groupsize),
u1 = rep(rnorm(ngroup, mean = 0, sd = 0.7), each = groupsize),
u0 = rep(rnorm(ngroup, mean = 0, sd = sqrt((-icc*(g01^2*var(z) + var(x1)*(g11^2*var(z) + var(u1)) + var(eij)) + g01^2*var(z)) / (icc-1))), each = groupsize),
beta0j = g00 + g01 * z + u0,
beta1j = g10 + g11 * z + u1,
y = beta0j + beta1j * x1 + eij
) %>%
select(-eij, -u1)
# Calculate ICC
iccdat <- var(data$beta0j) / var(data$y)
# Check if ICC is close to the desired value
if (abs(iccdat - icc) < 0.01) {
break  # Exit the loop if ICC is close enough to the desired value
} else {
# Adjust the variance of u0 to get closer to the desired ICC
data$u0 <- data$u0 * sqrt(icc / iccdat)
}
}
data <- data %>% select(-u0)
return(data)
}
stopCluster(cl)  # Stop the parallel processing
registerDoParallel(cl)
simdata <- foreach(icount(10)) %dopar% {
library(tidyverse)
repeat {
# Simulate data
data <- rnorm(n = (ngroup * groupsize), mean = 0, sd = 2.5) %>%
as_tibble() %>%
rename(x1 = value) %>%
mutate(
id = 1:(ngroup * groupsize),
group = rep(1:ngroup, each = groupsize),
eij = rnorm((ngroup * groupsize), mean = 0, sd = 3),
z = rep(rnorm(ngroup, mean = 0, sd = 1), each = groupsize),
u1 = rep(rnorm(ngroup, mean = 0, sd = 0.7), each = groupsize),
u0 = rep(rnorm(ngroup, mean = 0, sd = sqrt((-icc*(g01^2*var(z) + var(x1)*(g11^2*var(z) + var(u1)) + var(eij)) + g01^2*var(z)) / (icc-1))), each = groupsize),
beta0j = g00 + g01 * z + u0,
beta1j = g10 + g11 * z + u1,
y = beta0j + beta1j * x1 + eij
) %>%
select(-eij, -u1)
# Calculate ICC
iccdat <- var(data$beta0j) / var(data$y)
# Check if ICC is close to the desired value
if (abs(iccdat - icc) < 0.01) {
break  # Exit the loop if ICC is close enough to the desired value
} else {
# Adjust the variance of u0 to get closer to the desired ICC
data$u0 <- data$u0 * sqrt(icc / iccdat)
}
}
data <- data %>% select(-u0)
return(data)
}
unregister_dopar <- function() {
env <- foreach:::.foreachGlobals
rm(list=ls(name=env), pos=env)
}
unregister_dopar()
registerDoParallel(cl)
simdata <- foreach(icount(10)) %dopar% {
library(tidyverse)
repeat {
# Simulate data
data <- rnorm(n = (ngroup * groupsize), mean = 0, sd = 2.5) %>%
as_tibble() %>%
rename(x1 = value) %>%
mutate(
id = 1:(ngroup * groupsize),
group = rep(1:ngroup, each = groupsize),
eij = rnorm((ngroup * groupsize), mean = 0, sd = 3),
z = rep(rnorm(ngroup, mean = 0, sd = 1), each = groupsize),
u1 = rep(rnorm(ngroup, mean = 0, sd = 0.7), each = groupsize),
u0 = rep(rnorm(ngroup, mean = 0, sd = sqrt((-icc*(g01^2*var(z) + var(x1)*(g11^2*var(z) + var(u1)) + var(eij)) + g01^2*var(z)) / (icc-1))), each = groupsize),
beta0j = g00 + g01 * z + u0,
beta1j = g10 + g11 * z + u1,
y = beta0j + beta1j * x1 + eij
) %>%
select(-eij, -u1)
# Calculate ICC
iccdat <- var(data$beta0j) / var(data$y)
# Check if ICC is close to the desired value
if (abs(iccdat - icc) < 0.01) {
break  # Exit the loop if ICC is close enough to the desired value
} else {
# Adjust the variance of u0 to get closer to the desired ICC
data$u0 <- data$u0 * sqrt(icc / iccdat)
}
}
data <- data %>% select(-u0)
return(data)
}
# Using a constraint for data generation to make sure the ICC is .5. Process takes very long
library(foreach)
library(doParallel)
cores <- detectCores()
cl <- makeCluster(cores - 1)  # one less than total cores
registerDoParallel(cl)
simdata <- foreach(icount(10)) %dopar% {
library(tidyverse)
repeat {
# Simulate data
data <- rnorm(n = (ngroup * groupsize), mean = 0, sd = 2.5) %>%
as_tibble() %>%
rename(x1 = value) %>%
mutate(
id = 1:(ngroup * groupsize),
group = rep(1:ngroup, each = groupsize),
eij = rnorm((ngroup * groupsize), mean = 0, sd = 3),
z = rep(rnorm(ngroup, mean = 0, sd = 1), each = groupsize),
u1 = rep(rnorm(ngroup, mean = 0, sd = 0.7), each = groupsize),
u0 = rep(rnorm(ngroup, mean = 0, sd = sqrt((-icc*(g01^2*var(z) + var(x1)*(g11^2*var(z) + var(u1)) + var(eij)) + g01^2*var(z)) / (icc-1))), each = groupsize),
beta0j = g00 + g01 * z + u0,
beta1j = g10 + g11 * z + u1,
y = beta0j + beta1j * x1 + eij
) %>%
select(-eij, -u1)
# Calculate ICC
iccdat <- var(data$beta0j) / var(data$y)
# Check if ICC is close to the desired value
if (abs(iccdat - icc) < 0.01) {
break  # Exit the loop if ICC is close enough to the desired value
} else {
# Adjust the variance of u0 to get closer to the desired ICC
data$u0 <- data$u0 * sqrt(icc / iccdat)
}
}
data <- data %>% select(-u0)
return(data)
}
#############################
# Generate simulation data  #
#############################
# Non multivariate generation of the multilevel data set including manual equation for the variance of u0 to scale to the right ICC
simdata <- replicate(n = 1000,
expr = rnorm(n = (ngroup*groupsize),
mean = 0,
sd = 2.5) %>%
as_tibble() %>%
rename(x1 = value) %>%
mutate(id = 1:(ngroup*groupsize),
group = rep(1:ngroup, each = groupsize),
eij = rnorm((ngroup*groupsize), mean = 0, sd = 3),
z = rep(rnorm(ngroup, mean = 0, sd = 1), each = groupsize),
u1 = rep(rnorm(ngroup, mean = 0, sd = .7), each = groupsize),
u0 = rep(rnorm(ngroup, mean = 0, sd = 1.79*sqrt((-icc*(g01^2*var(z) + var(x1)*(g11^2*var(z) + var(u1)) + var(eij)) + g01^2*var(z)) / (icc-1))), each = groupsize),
beta0j = g00 + g01*z + u0,
beta1j = g10 + g11*z + u1,
y = beta0j + beta1j*x1 + eij) %>%
select(-eij, -u1, -u0),
simplify = FALSE)
for (i in 1:1000) {
repeat{
# Calculate ICC
iccdat <- var(simdata[[i]]$beta0j) / var(simdata[[i]]$y)
# Check if ICC is close to the desired value
if (abs(iccdat - icc) < 0.01) {
break  # Exit the loop if ICC is close enough to the desired value
} else {
# Adjust the variance of u0 to get closer to the desired ICC
simdata[[i]]$u0 <- simdata[[i]]$u0 * sqrt(icc / iccdat)}
}}
stopCluster(cl)  # Stop the parallel processing
################
# Checking ICC #
################
# Generating function for ICC calculation
iccfunction <- function (data) {
icc <- var(data$beta0j)/var(data$y)
return(icc)
}
# Checking ICC over all simulated data sets
iccvalue <- rep(0, 10000)
for(i in 1:10000) {
iccvalue[i] <- iccfunction(simdata[[i]])
}
mean(iccvalue)
#############################
# Generate simulation data  #
#############################
# Non multivariate generation of the multilevel data set including manual equation for the variance of u0 to scale to the right ICC
simdata <- replicate(n = 1000,
expr = rnorm(n = (ngroup*groupsize),
mean = 0,
sd = 2.5) %>%
as_tibble() %>%
rename(x1 = value) %>%
mutate(id = 1:(ngroup*groupsize),
group = rep(1:ngroup, each = groupsize),
eij = rnorm((ngroup*groupsize), mean = 0, sd = 3),
z = rep(rnorm(ngroup, mean = 0, sd = 1), each = groupsize),
u1 = rep(rnorm(ngroup, mean = 0, sd = .7), each = groupsize),
u0 = rep(rnorm(ngroup, mean = 0, sd = sqrt((-icc*(g01^2*var(z) + var(x1)*(g11^2*var(z) + var(u1)) + var(eij)) + g01^2*var(z)) / (icc-1))), each = groupsize), # 1.79*
beta0j = g00 + g01*z + u0,
beta1j = g10 + g11*z + u1,
y = beta0j + beta1j*x1 + eij) %>%
select(-eij, -u1, -u0),
simplify = FALSE)
for (i in 1:1000) {
repeat{
# Calculate ICC
iccdat <- var(simdata[[i]]$beta0j) / var(simdata[[i]]$y)
# Check if ICC is close to the desired value
if (abs(iccdat - icc) < 0.01) {
break  # Exit the loop if ICC is close enough to the desired value
} else {
# Adjust the variance of u0 to get closer to the desired ICC
simdata[[i]]$u0 <- simdata[[i]]$u0 * sqrt(icc / iccdat)}
}}
#############################
# Generate simulation data  #
#############################
# Non multivariate generation of the multilevel data set including manual equation for the variance of u0 to scale to the right ICC
simdata <- replicate(n = 1000,
expr = rnorm(n = (ngroup*groupsize),
mean = 0,
sd = 2.5) %>%
as_tibble() %>%
rename(x1 = value) %>%
mutate(id = 1:(ngroup*groupsize),
group = rep(1:ngroup, each = groupsize),
eij = rnorm((ngroup*groupsize), mean = 0, sd = 3),
z = rep(rnorm(ngroup, mean = 0, sd = 1), each = groupsize),
u1 = rep(rnorm(ngroup, mean = 0, sd = .7), each = groupsize),
u0 = rep(rnorm(ngroup, mean = 0, sd = sqrt((-icc*(g01^2*var(z) + var(x1)*(g11^2*var(z) + var(u1)) + var(eij)) + g01^2*var(z)) / (icc-1))), each = groupsize), # 1.79*
beta0j = g00 + g01*z + u0,
beta1j = g10 + g11*z + u1,
y = beta0j + beta1j*x1 + eij) %>%
select(-eij, -u1),
simplify = FALSE)
for (i in 1:1000) {
repeat{
# Calculate ICC
iccdat <- var(simdata[[i]]$beta0j) / var(simdata[[i]]$y)
# Check if ICC is close to the desired value
if (abs(iccdat - icc) < 0.01) {
break  # Exit the loop if ICC is close enough to the desired value
} else {
# Adjust the variance of u0 to get closer to the desired ICC
simdata[[i]]$u0 <- simdata[[i]]$u0 * sqrt(icc / iccdat)}
}}
